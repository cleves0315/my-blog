# 36. 有效的数独

### 题目描述

难度中等856收藏分享切换为英文接收动态反馈

请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

**注意：**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

**示例 1：**

![https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board =
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true

```

**示例 2：**

```
输入：board =
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为8以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

**提示：**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字（`1-9`）或者 `'.'`

### 题解

- 横向遍历校验是否重复
- 纵向遍历校验是否重复
- 在按每个3*3区域校验是否重复

```jsx
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
  const vertical = []

  for (let i = 0; i < 9; i++) { // 纵向
    const arr = []
    const map = new Map()

    for (let j = 0; j < 9; j++) { // 横向
      const bo = board[i][j]
      arr[j] = board[j][i]

      if (bo === '.' || !map.has(bo)) {
        map.set(bo)
      } else { // 横向检查重复数字
        return false
      }
    }
    vertical.push(arr);
  }

  for (let i = 0; i < 9; i++) { // 纵向
    const map = new Map()

    for (let j = 0; j < 9; j++) { // 横向
      const bo = vertical[i][j]

      if (bo === '.' || !map.has(bo)) {
        map.set(bo)
      } else { // 横向检查重复数字
        return false
      }
    }
  }

  const square = [
    [[0, 1, 2],[0, 1, 2]], [[3, 4, 5],[0, 1, 2]], [[6, 7, 8],[0, 1, 2]],
    [[0, 1, 2],[3, 4, 5]], [[3, 4, 5],[3, 4, 5]], [[6, 7, 8],[3, 4, 5]],
    [[0, 1, 2],[6, 7, 8]], [[3, 4, 5],[6, 7, 8]], [[6, 7, 8],[6, 7, 8]]
  ]

  for (let k = 0; k < square.length; k++) {
    const [X, Y] = square[k]
    const map = new Map()

    for (let i = 0; i < X.length; i++) {
      const x = X[i]

      for (let j = 0; j < Y.length; j++) {
        const y = Y[j]
        const bo = vertical[x][y]

        if (bo === '.' || !map.has(bo)) {
          map.set(bo)
        } else { // 横向检查重复数字
          return false
        }
      }
    }
  }

  return true
};
```