# 713. 乘积小于 K 的子数组

### 题目描述

难度中等523收藏分享切换为英文接收动态反馈

给你一个整数数组

```
nums
```

和一个整数

```
k
```

，请你返回子数组内所有元素的乘积严格小于

```
k
```

的连续子数组的数目。

**示例 1：**

```
输入：nums = [10,5,2,6], k = 100
输出：8
解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。

```

**示例 2：**

```
输入：nums = [1,2,3], k = 0
输出：0
```

**提示:**

- `1 <= nums.length <= 3 * 104`
- `1 <= nums[i] <= 1000`
- `0 <= k <= 106`

### 题解

```jsx
// 看了官方题解后，这里做下自己的理解
// 已知的重要条件：连续的子数组、子数组的乘积要小于 k（只有一个元素，那就直接跟 k 比较）
// 那么子数组只有一个数字时，[1] 那么能出现的次数是有1次（这里假设 k = 9999）
// 子数组有2个数字时，[1,2] 那能出现的次数有2次 [1,2] 和 [2]
// ...
// 子数组有5个数字时，[1,2,3,4,5] 
// 那能出现的次数有5次 [1,2,3,4,5]、[2,3,4,5]、[3,4,5]、[4,5]、[5]
// 为什么在[1,2,3,4,5]中，[1,2,3,4]、[2,3,4] 这些不能算在内？ 因为滑动窗口从左往右移动，这些场景都已经在之前的子数组中计算在内了
// 所以可以得知，当前窗口的子数组能出现的可能次数为子数组的长度
// 按照上面规则移动窗口，子数组乘数 < k 就把子数组长度累加（right - left + 1）

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var numSubarrayProductLessThanK = function(nums, k) {
  let mul = 1, num = 0

  for (let right = 0, left = 0; right < nums.length; right++) {
    mul *= nums[right]

    while(left <= right && mul >= k) {
      mul /= nums[left]
      left++
    }

    num += right - left + 1
  }

  return num
};
```